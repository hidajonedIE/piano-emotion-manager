commit 35907768b5c319fcdc3570a74e5490cc57d16478
Author: Piano Emotion Dev <dev@piano-emotion.com>
Date:   Fri Dec 26 05:55:41 2025 -0500

    feat: Integrate Clerk authentication system
    
    - Add @clerk/clerk-expo and @clerk/backend packages
    - Create ClerkProvider component with fallback support
    - Create login page with email/password and Google OAuth
    - Update AuthGuard to support both Clerk and legacy auth
    - Add Clerk token verification in server context
    - Update /api/auth/me to support Clerk authentication
    - Create use-auth-legacy.ts as fallback hook
    - Update use-auth.ts to use Clerk when available
    - Add clerk.ts server module for token verification
    - Update app.config.ts with Clerk configuration

diff --git a/api/auth/me.ts b/api/auth/me.ts
index 14eb90f..52d14c9 100644
--- a/api/auth/me.ts
+++ b/api/auth/me.ts
@@ -1,6 +1,10 @@
 import type { VercelRequest, VercelResponse } from "@vercel/node";
 import { COOKIE_NAME } from "../../shared/const.js";
 import { sdk } from "../../server/_core/sdk.js";
+import { verifyClerkSession, getOrCreateUserFromClerk } from "../../server/_core/clerk.js";
+import { db } from "../../server/db/index.js";
+import { users } from "../../drizzle/schema.js";
+import { eq } from "drizzle-orm";
 
 export default async function handler(req: VercelRequest, res: VercelResponse) {
   if (req.method !== "GET") {
@@ -8,6 +12,23 @@ export default async function handler(req: VercelRequest, res: VercelResponse) {
   }
 
   try {
+    // Try Clerk authentication first (new system)
+    const clerkUser = await verifyClerkSession(req);
+    if (clerkUser) {
+      const dbUser = await getOrCreateUserFromClerk(clerkUser, db, users, eq);
+      return res.json({
+        user: {
+          id: dbUser.id,
+          openId: dbUser.openId || clerkUser.id,
+          name: dbUser.name,
+          email: dbUser.email,
+          loginMethod: "clerk",
+          lastSignedIn: (dbUser.lastSignedIn ?? new Date()).toISOString(),
+        }
+      });
+    }
+
+    // Fall back to legacy SDK authentication
     // Try to get token from cookie first, then from Authorization header
     const cookieToken = req.cookies?.[COOKIE_NAME];
     const authHeader = req.headers.authorization || req.headers.Authorization;
diff --git a/app.config.ts b/app.config.ts
index 6f31ab0..380786a 100644
--- a/app.config.ts
+++ b/app.config.ts
@@ -14,6 +14,8 @@ const env = {
   // App branding - update these values directly (do not use env vars)
   appName: 'Piano Emotion Manager',
   appSlug: 'piano_tech_app',
+  // Clerk publishable key
+  clerkPublishableKey: process.env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY || process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || '',
   // S3 URL of the app logo - set this to the URL returned by generate_image when creating custom logo
   // Leave empty to use the default icon from assets/images/icon.png
   logoUrl: 'https://files.manuscdn.com/user_upload_by_module/session_file/110818387/JwKlBILQLDvJoMpv.png',
@@ -105,6 +107,9 @@ const config: ExpoConfig = {
     reactCompiler: true,
 	tsconfigPaths: true,
   },
+  extra: {
+    clerkPublishableKey: env.clerkPublishableKey,
+  },
 };
 
 export default config;
diff --git a/app/_layout.tsx b/app/_layout.tsx
index faac912..04e3fac 100644
--- a/app/_layout.tsx
+++ b/app/_layout.tsx
@@ -25,6 +25,7 @@ import { DistributorProvider } from "@/contexts/distributor-context";
 import { SubscriptionProvider } from "@/contexts/SubscriptionContext";
 import { AIAssistant } from "@/components/ai/AIAssistant";
 import { AuthGuard } from "@/components/auth-guard";
+import { ClerkProvider } from "@/components/clerk-provider";
 
 const DEFAULT_WEB_INSETS: EdgeInsets = { top: 0, right: 0, bottom: 0, left: 0 };
 const DEFAULT_WEB_FRAME: Rect = { x: 0, y: 0, width: 0, height: 0 };
@@ -117,53 +118,57 @@ export default function RootLayout() {
 
   const content = (
     <GestureHandlerRootView style={{ flex: 1 }}>
-      <trpc.Provider client={trpcClient} queryClient={queryClient}>
-        <QueryClientProvider client={queryClient}>
-          <ThemeProvider value={colorScheme === "dark" ? DarkTheme : DefaultTheme}>
-            <DistributorProvider>
-              <SubscriptionProvider>
-                <LanguageProvider>
-                  <SnackbarProvider>
-                  <AuthGuard>
-                  <Stack>
-                    <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
-                    <Stack.Screen name="(app)" options={{ headerShown: false }} />
-                    <Stack.Screen name="settings" options={{ headerShown: false }} />
-                    <Stack.Screen name="modal" options={{ presentation: "modal", title: "Modal" }} />
-                    <Stack.Screen name="oauth/callback" options={{ headerShown: false }} />
-                    <Stack.Screen name="portal" options={{ headerShown: false }} />
-                    <Stack.Screen name="quote" options={{ headerShown: false }} />
-                    <Stack.Screen name="client" options={{ headerShown: false }} />
-                    <Stack.Screen name="piano" options={{ headerShown: false }} />
-                    <Stack.Screen name="service" options={{ headerShown: false }} />
-                    <Stack.Screen name="invoice" options={{ headerShown: false }} />
-                    <Stack.Screen name="appointment" options={{ headerShown: false }} />
-                    <Stack.Screen name="supplier" options={{ headerShown: false }} />
-                    <Stack.Screen name="rate" options={{ headerShown: false }} />
-                    <Stack.Screen name="inventory" options={{ headerShown: false }} />
-                    <Stack.Screen name="analytics" options={{ headerShown: false }} />
-                    <Stack.Screen name="accounting" options={{ headerShown: false }} />
-                    <Stack.Screen name="work-order" options={{ headerShown: false }} />
-                    <Stack.Screen name="teams" options={{ headerShown: false }} />
-                    <Stack.Screen name="quotes" options={{ headerShown: false }} />
-                    <Stack.Screen name="reminders" options={{ headerShown: false }} />
-                    <Stack.Screen name="workflows" options={{ headerShown: false }} />
-                    <Stack.Screen name="contracts" options={{ headerShown: false }} />
-                    <Stack.Screen name="whatsapp-settings" options={{ headerShown: false }} />
-                    <Stack.Screen name="payment-settings" options={{ headerShown: false }} />
-                    <Stack.Screen name="dashboard-editor" options={{ headerShown: false }} />
-                    <Stack.Screen name="predictions" options={{ headerShown: false }} />
-                  </Stack>
-                  </AuthGuard>
-                  <StatusBar style="auto" />
-                  <AIAssistant />
-                  </SnackbarProvider>
-                </LanguageProvider>
-              </SubscriptionProvider>
-            </DistributorProvider>
-          </ThemeProvider>
-        </QueryClientProvider>
-      </trpc.Provider>
+      <ClerkProvider>
+        <trpc.Provider client={trpcClient} queryClient={queryClient}>
+          <QueryClientProvider client={queryClient}>
+            <ThemeProvider value={colorScheme === "dark" ? DarkTheme : DefaultTheme}>
+              <DistributorProvider>
+                <SubscriptionProvider>
+                  <LanguageProvider>
+                    <SnackbarProvider>
+                    <AuthGuard>
+                    <Stack>
+                      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
+                      <Stack.Screen name="(app)" options={{ headerShown: false }} />
+                      <Stack.Screen name="settings" options={{ headerShown: false }} />
+                      <Stack.Screen name="modal" options={{ presentation: "modal", title: "Modal" }} />
+                      <Stack.Screen name="login" options={{ headerShown: false }} />
+                      <Stack.Screen name="sign-up" options={{ headerShown: false }} />
+                      <Stack.Screen name="oauth/callback" options={{ headerShown: false }} />
+                      <Stack.Screen name="portal" options={{ headerShown: false }} />
+                      <Stack.Screen name="quote" options={{ headerShown: false }} />
+                      <Stack.Screen name="client" options={{ headerShown: false }} />
+                      <Stack.Screen name="piano" options={{ headerShown: false }} />
+                      <Stack.Screen name="service" options={{ headerShown: false }} />
+                      <Stack.Screen name="invoice" options={{ headerShown: false }} />
+                      <Stack.Screen name="appointment" options={{ headerShown: false }} />
+                      <Stack.Screen name="supplier" options={{ headerShown: false }} />
+                      <Stack.Screen name="rate" options={{ headerShown: false }} />
+                      <Stack.Screen name="inventory" options={{ headerShown: false }} />
+                      <Stack.Screen name="analytics" options={{ headerShown: false }} />
+                      <Stack.Screen name="accounting" options={{ headerShown: false }} />
+                      <Stack.Screen name="work-order" options={{ headerShown: false }} />
+                      <Stack.Screen name="teams" options={{ headerShown: false }} />
+                      <Stack.Screen name="quotes" options={{ headerShown: false }} />
+                      <Stack.Screen name="reminders" options={{ headerShown: false }} />
+                      <Stack.Screen name="workflows" options={{ headerShown: false }} />
+                      <Stack.Screen name="contracts" options={{ headerShown: false }} />
+                      <Stack.Screen name="whatsapp-settings" options={{ headerShown: false }} />
+                      <Stack.Screen name="payment-settings" options={{ headerShown: false }} />
+                      <Stack.Screen name="dashboard-editor" options={{ headerShown: false }} />
+                      <Stack.Screen name="predictions" options={{ headerShown: false }} />
+                    </Stack>
+                    </AuthGuard>
+                    <StatusBar style="auto" />
+                    <AIAssistant />
+                    </SnackbarProvider>
+                  </LanguageProvider>
+                </SubscriptionProvider>
+              </DistributorProvider>
+            </ThemeProvider>
+          </QueryClientProvider>
+        </trpc.Provider>
+      </ClerkProvider>
     </GestureHandlerRootView>
   );
 
diff --git a/app/login.tsx b/app/login.tsx
new file mode 100644
index 0000000..22b4cca
--- /dev/null
+++ b/app/login.tsx
@@ -0,0 +1,437 @@
+import { useSignIn, useSignUp, useAuth } from "@clerk/clerk-expo";
+import { useRouter } from "expo-router";
+import { useState, useCallback, useEffect } from "react";
+import {
+  View,
+  Text,
+  TextInput,
+  Pressable,
+  StyleSheet,
+  ActivityIndicator,
+  KeyboardAvoidingView,
+  Platform,
+  ScrollView,
+  Image,
+} from "react-native";
+import * as WebBrowser from "expo-web-browser";
+import * as Linking from "expo-linking";
+
+// Completar el flujo de OAuth en web
+if (Platform.OS === "web") {
+  WebBrowser.maybeCompleteAuthSession();
+}
+
+type AuthMode = "signIn" | "signUp";
+
+export default function LoginScreen() {
+  const { signIn, setActive: setSignInActive, isLoaded: isSignInLoaded } = useSignIn();
+  const { signUp, setActive: setSignUpActive, isLoaded: isSignUpLoaded } = useSignUp();
+  const { isSignedIn } = useAuth();
+  const router = useRouter();
+
+  const [mode, setMode] = useState<AuthMode>("signIn");
+  const [email, setEmail] = useState("");
+  const [password, setPassword] = useState("");
+  const [name, setName] = useState("");
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [pendingVerification, setPendingVerification] = useState(false);
+  const [verificationCode, setVerificationCode] = useState("");
+
+  // Redirigir si ya est谩 autenticado
+  useEffect(() => {
+    if (isSignedIn) {
+      router.replace("/");
+    }
+  }, [isSignedIn, router]);
+
+  const handleEmailSignIn = useCallback(async () => {
+    if (!isSignInLoaded || !signIn) return;
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      const result = await signIn.create({
+        identifier: email,
+        password,
+      });
+
+      if (result.status === "complete") {
+        await setSignInActive({ session: result.createdSessionId });
+        router.replace("/");
+      } else {
+        console.log("[Login] Sign in incomplete:", result);
+        setError("Error al iniciar sesi贸n. Por favor, int茅ntalo de nuevo.");
+      }
+    } catch (err: any) {
+      console.error("[Login] Sign in error:", err);
+      if (err.errors?.[0]?.message) {
+        setError(err.errors[0].message);
+      } else {
+        setError("Error al iniciar sesi贸n. Verifica tus credenciales.");
+      }
+    } finally {
+      setLoading(false);
+    }
+  }, [isSignInLoaded, signIn, email, password, setSignInActive, router]);
+
+  const handleEmailSignUp = useCallback(async () => {
+    if (!isSignUpLoaded || !signUp) return;
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      await signUp.create({
+        emailAddress: email,
+        password,
+        firstName: name.split(" ")[0] || name,
+        lastName: name.split(" ").slice(1).join(" ") || undefined,
+      });
+
+      // Enviar c贸digo de verificaci贸n
+      await signUp.prepareEmailAddressVerification({ strategy: "email_code" });
+      setPendingVerification(true);
+    } catch (err: any) {
+      console.error("[Login] Sign up error:", err);
+      if (err.errors?.[0]?.message) {
+        setError(err.errors[0].message);
+      } else {
+        setError("Error al crear la cuenta. Por favor, int茅ntalo de nuevo.");
+      }
+    } finally {
+      setLoading(false);
+    }
+  }, [isSignUpLoaded, signUp, email, password, name]);
+
+  const handleVerification = useCallback(async () => {
+    if (!isSignUpLoaded || !signUp) return;
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      const result = await signUp.attemptEmailAddressVerification({
+        code: verificationCode,
+      });
+
+      if (result.status === "complete") {
+        await setSignUpActive({ session: result.createdSessionId });
+        router.replace("/");
+      } else {
+        setError("C贸digo de verificaci贸n incorrecto.");
+      }
+    } catch (err: any) {
+      console.error("[Login] Verification error:", err);
+      if (err.errors?.[0]?.message) {
+        setError(err.errors[0].message);
+      } else {
+        setError("Error al verificar el c贸digo.");
+      }
+    } finally {
+      setLoading(false);
+    }
+  }, [isSignUpLoaded, signUp, verificationCode, setSignUpActive, router]);
+
+  const handleGoogleSignIn = useCallback(async () => {
+    if (!isSignInLoaded || !signIn) return;
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      const redirectUrl = Linking.createURL("/");
+
+      const { createdSessionId, signIn: signInResult, signUp: signUpResult } = await signIn.create({
+        strategy: "oauth_google",
+        redirectUrl,
+      });
+
+      if (createdSessionId) {
+        await setSignInActive({ session: createdSessionId });
+        router.replace("/");
+      } else {
+        // Abrir el flujo de OAuth
+        const { externalVerificationRedirectURL } = signInResult || signUpResult || {};
+        if (externalVerificationRedirectURL) {
+          if (Platform.OS === "web") {
+            window.location.href = externalVerificationRedirectURL.toString();
+          } else {
+            await WebBrowser.openAuthSessionAsync(
+              externalVerificationRedirectURL.toString(),
+              redirectUrl
+            );
+          }
+        }
+      }
+    } catch (err: any) {
+      console.error("[Login] Google sign in error:", err);
+      setError("Error al iniciar sesi贸n con Google.");
+    } finally {
+      setLoading(false);
+    }
+  }, [isSignInLoaded, signIn, setSignInActive, router]);
+
+  // Pantalla de verificaci贸n de email
+  if (pendingVerification) {
+    return (
+      <View style={styles.container}>
+        <View style={styles.card}>
+          <Text style={styles.title}>Verificar Email</Text>
+          <Text style={styles.subtitle}>
+            Hemos enviado un c贸digo de verificaci贸n a {email}
+          </Text>
+
+          {error && <Text style={styles.error}>{error}</Text>}
+
+          <TextInput
+            style={styles.input}
+            placeholder="C贸digo de verificaci贸n"
+            value={verificationCode}
+            onChangeText={setVerificationCode}
+            keyboardType="number-pad"
+            autoCapitalize="none"
+          />
+
+          <Pressable
+            style={[styles.button, styles.primaryButton]}
+            onPress={handleVerification}
+            disabled={loading}
+          >
+            {loading ? (
+              <ActivityIndicator color="#fff" />
+            ) : (
+              <Text style={styles.buttonText}>Verificar</Text>
+            )}
+          </Pressable>
+
+          <Pressable
+            style={styles.linkButton}
+            onPress={() => {
+              setPendingVerification(false);
+              setVerificationCode("");
+            }}
+          >
+            <Text style={styles.linkText}>Volver</Text>
+          </Pressable>
+        </View>
+      </View>
+    );
+  }
+
+  return (
+    <KeyboardAvoidingView
+      style={styles.container}
+      behavior={Platform.OS === "ios" ? "padding" : "height"}
+    >
+      <ScrollView
+        contentContainerStyle={styles.scrollContent}
+        keyboardShouldPersistTaps="handled"
+      >
+        <View style={styles.card}>
+          {/* Logo */}
+          <View style={styles.logoContainer}>
+            <Text style={styles.logoText}></Text>
+            <Text style={styles.appName}>Piano Emotion Manager</Text>
+          </View>
+
+          <Text style={styles.title}>
+            {mode === "signIn" ? "Iniciar Sesi贸n" : "Crear Cuenta"}
+          </Text>
+
+          {error && <Text style={styles.error}>{error}</Text>}
+
+          {/* Google Sign In */}
+          <Pressable
+            style={[styles.button, styles.googleButton]}
+            onPress={handleGoogleSignIn}
+            disabled={loading}
+          >
+            <Text style={styles.googleButtonText}>
+              {loading ? "Cargando..." : "Continuar con Google"}
+            </Text>
+          </Pressable>
+
+          <View style={styles.divider}>
+            <View style={styles.dividerLine} />
+            <Text style={styles.dividerText}>o</Text>
+            <View style={styles.dividerLine} />
+          </View>
+
+          {/* Email/Password Form */}
+          {mode === "signUp" && (
+            <TextInput
+              style={styles.input}
+              placeholder="Nombre completo"
+              value={name}
+              onChangeText={setName}
+              autoCapitalize="words"
+            />
+          )}
+
+          <TextInput
+            style={styles.input}
+            placeholder="Email"
+            value={email}
+            onChangeText={setEmail}
+            keyboardType="email-address"
+            autoCapitalize="none"
+            autoComplete="email"
+          />
+
+          <TextInput
+            style={styles.input}
+            placeholder="Contrase帽a"
+            value={password}
+            onChangeText={setPassword}
+            secureTextEntry
+            autoCapitalize="none"
+          />
+
+          <Pressable
+            style={[styles.button, styles.primaryButton]}
+            onPress={mode === "signIn" ? handleEmailSignIn : handleEmailSignUp}
+            disabled={loading}
+          >
+            {loading ? (
+              <ActivityIndicator color="#fff" />
+            ) : (
+              <Text style={styles.buttonText}>
+                {mode === "signIn" ? "Iniciar Sesi贸n" : "Crear Cuenta"}
+              </Text>
+            )}
+          </Pressable>
+
+          {/* Toggle Mode */}
+          <Pressable
+            style={styles.linkButton}
+            onPress={() => {
+              setMode(mode === "signIn" ? "signUp" : "signIn");
+              setError(null);
+            }}
+          >
+            <Text style={styles.linkText}>
+              {mode === "signIn"
+                ? "驴No tienes cuenta? Reg铆strate"
+                : "驴Ya tienes cuenta? Inicia sesi贸n"}
+            </Text>
+          </Pressable>
+        </View>
+      </ScrollView>
+    </KeyboardAvoidingView>
+  );
+}
+
+const styles = StyleSheet.create({
+  container: {
+    flex: 1,
+    backgroundColor: "#f5f5f5",
+  },
+  scrollContent: {
+    flexGrow: 1,
+    justifyContent: "center",
+    padding: 20,
+  },
+  card: {
+    backgroundColor: "#fff",
+    borderRadius: 16,
+    padding: 24,
+    shadowColor: "#000",
+    shadowOffset: { width: 0, height: 2 },
+    shadowOpacity: 0.1,
+    shadowRadius: 8,
+    elevation: 4,
+    maxWidth: 400,
+    width: "100%",
+    alignSelf: "center",
+  },
+  logoContainer: {
+    alignItems: "center",
+    marginBottom: 24,
+  },
+  logoText: {
+    fontSize: 48,
+    marginBottom: 8,
+  },
+  appName: {
+    fontSize: 20,
+    fontWeight: "600",
+    color: "#333",
+  },
+  title: {
+    fontSize: 24,
+    fontWeight: "bold",
+    textAlign: "center",
+    marginBottom: 8,
+    color: "#333",
+  },
+  subtitle: {
+    fontSize: 14,
+    textAlign: "center",
+    marginBottom: 24,
+    color: "#666",
+  },
+  error: {
+    color: "#dc2626",
+    textAlign: "center",
+    marginBottom: 16,
+    fontSize: 14,
+  },
+  input: {
+    borderWidth: 1,
+    borderColor: "#ddd",
+    borderRadius: 8,
+    padding: 12,
+    marginBottom: 12,
+    fontSize: 16,
+    backgroundColor: "#fafafa",
+  },
+  button: {
+    borderRadius: 8,
+    padding: 14,
+    alignItems: "center",
+    marginBottom: 12,
+  },
+  primaryButton: {
+    backgroundColor: "#007AFF",
+  },
+  googleButton: {
+    backgroundColor: "#fff",
+    borderWidth: 1,
+    borderColor: "#ddd",
+  },
+  buttonText: {
+    color: "#fff",
+    fontSize: 16,
+    fontWeight: "600",
+  },
+  googleButtonText: {
+    color: "#333",
+    fontSize: 16,
+    fontWeight: "600",
+  },
+  divider: {
+    flexDirection: "row",
+    alignItems: "center",
+    marginVertical: 20,
+  },
+  dividerLine: {
+    flex: 1,
+    height: 1,
+    backgroundColor: "#ddd",
+  },
+  dividerText: {
+    marginHorizontal: 16,
+    color: "#999",
+    fontSize: 14,
+  },
+  linkButton: {
+    padding: 8,
+    alignItems: "center",
+  },
+  linkText: {
+    color: "#007AFF",
+    fontSize: 14,
+  },
+});
diff --git a/components/auth-guard.tsx b/components/auth-guard.tsx
index 631246c..5c8616b 100644
--- a/components/auth-guard.tsx
+++ b/components/auth-guard.tsx
@@ -1,57 +1,81 @@
-import { useAuth } from "@/hooks/use-auth";
 import { useEffect, useState } from "react";
 import { Platform, View, ActivityIndicator, StyleSheet, Text } from "react-native";
 import { useRouter, usePathname } from "expo-router";
+import * as WebBrowser from "expo-web-browser";
+
+// Try to import Clerk hooks - they may not be available if Clerk is not configured
+let useClerkAuth: any = null;
+let useClerkUser: any = null;
+
+try {
+  const clerk = require("@clerk/clerk-expo");
+  useClerkAuth = clerk.useAuth;
+  useClerkUser = clerk.useUser;
+} catch (e) {
+  console.log("[AuthGuard] Clerk not available, using fallback auth");
+}
+
+// Fallback hook for when Clerk is not available
+import { useAuth as useLegacyAuth } from "@/hooks/use-auth-legacy";
 
 type AuthGuardProps = {
   children: React.ReactNode;
 };
 
 // Rutas que no requieren autenticaci贸n
-const PUBLIC_ROUTES = ["/oauth/callback", "/login", "/portal", "/api/auth/demo-login"];
+const PUBLIC_ROUTES = ["/login", "/sign-up", "/portal", "/api/", "/oauth/callback"];
 
-// URL de demo login - usa el endpoint local que crea sesi贸n sin OAuth externo
-function getDemoLoginUrl(): string {
-  if (Platform.OS === "web" && typeof window !== "undefined") {
-    const currentUrl = encodeURIComponent(window.location.pathname);
-    return `/api/auth/demo-login?redirect=${currentUrl}`;
-  }
-  return "/api/auth/demo-login";
+// Completar el flujo de autenticaci贸n en web
+if (Platform.OS === "web") {
+  WebBrowser.maybeCompleteAuthSession();
 }
 
 export function AuthGuard({ children }: AuthGuardProps) {
-  const { user, loading, isAuthenticated } = useAuth();
   const router = useRouter();
   const pathname = usePathname();
   const [redirecting, setRedirecting] = useState(false);
 
+  // Use Clerk if available, otherwise use legacy auth
+  const clerkAuth = useClerkAuth?.() || { isLoaded: true, isSignedIn: false };
+  const legacyAuth = useLegacyAuth();
+  
+  // Determine if Clerk is being used
+  const usingClerk = useClerkAuth !== null;
+  
+  // Get authentication state
+  const isLoaded = usingClerk ? clerkAuth.isLoaded : !legacyAuth.loading;
+  const isSignedIn = usingClerk ? clerkAuth.isSignedIn : legacyAuth.isAuthenticated;
+
   useEffect(() => {
     // No hacer nada mientras carga
-    if (loading) return;
+    if (!isLoaded) return;
 
     // Verificar si es una ruta p煤blica
     const isPublicRoute = PUBLIC_ROUTES.some((route) => pathname?.startsWith(route));
     if (isPublicRoute) return;
 
-    // Si no est谩 autenticado, redirigir a demo login
-    if (!isAuthenticated && !redirecting) {
-      console.log("[AuthGuard] No authenticated user, redirecting to demo login...");
+    // Si no est谩 autenticado, redirigir a login
+    if (!isSignedIn && !redirecting) {
+      console.log("[AuthGuard] No authenticated user, redirecting to login...");
       setRedirecting(true);
-
-      if (Platform.OS === "web") {
-        // En web, redirigir al endpoint de demo login
-        const loginUrl = getDemoLoginUrl();
-        console.log("[AuthGuard] Redirecting to:", loginUrl);
-        window.location.href = loginUrl;
-      } else {
-        // En native, navegar a una pantalla de login
+      
+      if (usingClerk) {
+        // Redirect to Clerk login page
         router.replace("/login");
+      } else {
+        // Redirect to demo login for legacy auth
+        if (Platform.OS === "web" && typeof window !== "undefined") {
+          const currentUrl = encodeURIComponent(window.location.pathname);
+          window.location.href = `/api/auth/demo-login?redirect=${currentUrl}`;
+        } else {
+          router.replace("/login");
+        }
       }
     }
-  }, [loading, isAuthenticated, pathname, redirecting, router]);
+  }, [isLoaded, isSignedIn, pathname, redirecting, router, usingClerk]);
 
-  // Mostrar loading mientras verifica autenticaci贸n
-  if (loading) {
+  // Mostrar loading mientras carga
+  if (!isLoaded) {
     return (
       <View style={styles.container}>
         <ActivityIndicator size="large" color="#007AFF" />
@@ -60,12 +84,20 @@ export function AuthGuard({ children }: AuthGuardProps) {
     );
   }
 
+  // Verificar si es una ruta p煤blica
+  const isPublicRoute = PUBLIC_ROUTES.some((route) => pathname?.startsWith(route));
+
+  // Si es ruta p煤blica, mostrar contenido sin verificar auth
+  if (isPublicRoute) {
+    return <>{children}</>;
+  }
+
   // Mostrar loading mientras redirige
-  if (redirecting || (!isAuthenticated && !PUBLIC_ROUTES.some((route) => pathname?.startsWith(route)))) {
+  if (redirecting || !isSignedIn) {
     return (
       <View style={styles.container}>
         <ActivityIndicator size="large" color="#007AFF" />
-        <Text style={styles.text}>Iniciando sesi贸n de demostraci贸n...</Text>
+        <Text style={styles.text}>Redirigiendo a inicio de sesi贸n...</Text>
       </View>
     );
   }
diff --git a/components/clerk-provider.tsx b/components/clerk-provider.tsx
new file mode 100644
index 0000000..aed1dd9
--- /dev/null
+++ b/components/clerk-provider.tsx
@@ -0,0 +1,51 @@
+import { ClerkProvider as ClerkProviderBase, ClerkLoaded } from "@clerk/clerk-expo";
+import { tokenCache } from "@/lib/clerk-token-cache";
+import Constants from "expo-constants";
+import { Platform } from "react-native";
+
+type ClerkProviderProps = {
+  children: React.ReactNode;
+};
+
+// Get the publishable key from environment variables
+function getPublishableKey(): string {
+  // Try multiple sources for the key
+  if (Platform.OS === "web" && typeof window !== "undefined") {
+    // Check if key is injected in window
+    const windowKey = (window as any).__CLERK_PUBLISHABLE_KEY__;
+    if (windowKey) return windowKey;
+  }
+  
+  // Check environment variables
+  const envKey = process.env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY || 
+                 process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;
+  if (envKey) return envKey;
+  
+  // Check Expo config
+  const configKey = Constants.expoConfig?.extra?.clerkPublishableKey;
+  if (configKey) return configKey;
+  
+  return "";
+}
+
+const publishableKey = getPublishableKey();
+
+export function ClerkProvider({ children }: ClerkProviderProps) {
+  // If no publishable key, render children without Clerk wrapper
+  // This allows the app to work with demo login while Clerk is being set up
+  if (!publishableKey) {
+    console.warn("[ClerkProvider] No publishable key found. Using fallback authentication.");
+    return <>{children}</>;
+  }
+
+  return (
+    <ClerkProviderBase 
+      publishableKey={publishableKey}
+      tokenCache={Platform.OS !== "web" ? tokenCache : undefined}
+    >
+      <ClerkLoaded>
+        {children}
+      </ClerkLoaded>
+    </ClerkProviderBase>
+  );
+}
diff --git a/hooks/use-auth-legacy.ts b/hooks/use-auth-legacy.ts
new file mode 100644
index 0000000..bc43185
--- /dev/null
+++ b/hooks/use-auth-legacy.ts
@@ -0,0 +1,143 @@
+import * as Api from "@/lib/api";
+import * as Auth from "@/lib/auth";
+import { useCallback, useEffect, useMemo, useState } from "react";
+import { Platform } from "react-native";
+
+type UseAuthOptions = {
+  autoFetch?: boolean;
+};
+
+export function useAuth(options?: UseAuthOptions) {
+  const { autoFetch = true } = options ?? {};
+  const [user, setUser] = useState<Auth.User | null>(null);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<Error | null>(null);
+
+  const fetchUser = useCallback(async () => {
+    console.log("[useAuth-legacy] fetchUser called");
+    try {
+      setLoading(true);
+      setError(null);
+
+      // Web platform: use cookie-based auth, fetch user from API
+      if (Platform.OS === "web") {
+        console.log("[useAuth-legacy] Web platform: fetching user from API...");
+        const apiUser = await Api.getMe();
+        console.log("[useAuth-legacy] API user response:", apiUser);
+
+        if (apiUser) {
+          const userInfo: Auth.User = {
+            id: apiUser.id,
+            openId: apiUser.openId,
+            name: apiUser.name,
+            email: apiUser.email,
+            loginMethod: apiUser.loginMethod,
+            lastSignedIn: new Date(apiUser.lastSignedIn),
+          };
+          setUser(userInfo);
+          // Cache user info in localStorage for faster subsequent loads
+          await Auth.setUserInfo(userInfo);
+          console.log("[useAuth-legacy] Web user set from API:", userInfo);
+        } else {
+          console.log("[useAuth-legacy] Web: No authenticated user from API");
+          setUser(null);
+          await Auth.clearUserInfo();
+        }
+        return;
+      }
+
+      // Native platform: use token-based auth
+      console.log("[useAuth-legacy] Native platform: checking for session token...");
+      const sessionToken = await Auth.getSessionToken();
+      console.log(
+        "[useAuth-legacy] Session token:",
+        sessionToken ? `present (${sessionToken.substring(0, 20)}...)` : "missing",
+      );
+      if (!sessionToken) {
+        console.log("[useAuth-legacy] No session token, setting user to null");
+        setUser(null);
+        return;
+      }
+
+      // Use cached user info for native (token validates the session)
+      const cachedUser = await Auth.getUserInfo();
+      console.log("[useAuth-legacy] Cached user:", cachedUser);
+      if (cachedUser) {
+        console.log("[useAuth-legacy] Using cached user info");
+        setUser(cachedUser);
+      } else {
+        console.log("[useAuth-legacy] No cached user, setting user to null");
+        setUser(null);
+      }
+    } catch (err) {
+      const error = err instanceof Error ? err : new Error("Failed to fetch user");
+      console.error("[useAuth-legacy] fetchUser error:", error);
+      setError(error);
+      setUser(null);
+    } finally {
+      setLoading(false);
+      console.log("[useAuth-legacy] fetchUser completed, loading:", false);
+    }
+  }, []);
+
+  const logout = useCallback(async () => {
+    try {
+      await Api.logout();
+    } catch (err) {
+      console.error("[Auth-legacy] Logout API call failed:", err);
+      // Continue with logout even if API call fails
+    } finally {
+      await Auth.removeSessionToken();
+      await Auth.clearUserInfo();
+      setUser(null);
+      setError(null);
+    }
+  }, []);
+
+  const isAuthenticated = useMemo(() => Boolean(user), [user]);
+
+  useEffect(() => {
+    console.log("[useAuth-legacy] useEffect triggered, autoFetch:", autoFetch, "platform:", Platform.OS);
+    if (autoFetch) {
+      if (Platform.OS === "web") {
+        // Web: fetch user from API directly (user will login manually if needed)
+        console.log("[useAuth-legacy] Web: fetching user from API...");
+        fetchUser();
+      } else {
+        // Native: check for cached user info first for faster initial load
+        Auth.getUserInfo().then((cachedUser) => {
+          console.log("[useAuth-legacy] Native cached user check:", cachedUser);
+          if (cachedUser) {
+            console.log("[useAuth-legacy] Native: setting cached user immediately");
+            setUser(cachedUser);
+            setLoading(false);
+          } else {
+            // No cached user, check session token
+            fetchUser();
+          }
+        });
+      }
+    } else {
+      console.log("[useAuth-legacy] autoFetch disabled, setting loading to false");
+      setLoading(false);
+    }
+  }, [autoFetch, fetchUser]);
+
+  useEffect(() => {
+    console.log("[useAuth-legacy] State updated:", {
+      hasUser: !!user,
+      loading,
+      isAuthenticated,
+      error: error?.message,
+    });
+  }, [user, loading, isAuthenticated, error]);
+
+  return {
+    user,
+    loading,
+    error,
+    isAuthenticated,
+    refresh: fetchUser,
+    logout,
+  };
+}
diff --git a/hooks/use-auth.ts b/hooks/use-auth.ts
index f1a9fda..d0e460b 100644
--- a/hooks/use-auth.ts
+++ b/hooks/use-auth.ts
@@ -1,143 +1,101 @@
-import * as Api from "@/lib/api";
-import * as Auth from "@/lib/auth";
-import { useCallback, useEffect, useMemo, useState } from "react";
-import { Platform } from "react-native";
+import { useCallback, useMemo } from "react";
+import type { User } from "@/lib/auth";
+
+// Try to import Clerk hooks - they may not be available if Clerk is not configured
+let useClerkAuth: any = null;
+let useClerkUser: any = null;
+
+try {
+  const clerk = require("@clerk/clerk-expo");
+  useClerkAuth = clerk.useAuth;
+  useClerkUser = clerk.useUser;
+} catch (e) {
+  console.log("[useAuth] Clerk not available");
+}
+
+// Import legacy auth as fallback
+import { useAuth as useLegacyAuth } from "@/hooks/use-auth-legacy";
 
 type UseAuthOptions = {
   autoFetch?: boolean;
 };
 
 export function useAuth(options?: UseAuthOptions) {
-  const { autoFetch = true } = options ?? {};
-  const [user, setUser] = useState<Auth.User | null>(null);
-  const [loading, setLoading] = useState(true);
-  const [error, setError] = useState<Error | null>(null);
+  // Check if Clerk is available
+  const usingClerk = useClerkAuth !== null;
+  
+  // Use Clerk hooks if available
+  const clerkAuth = useClerkAuth?.() || { isLoaded: true, isSignedIn: false, signOut: async () => {}, getToken: async () => null };
+  const clerkUserHook = useClerkUser?.() || { user: null, isLoaded: true };
+  
+  // Use legacy auth as fallback
+  const legacyAuth = useLegacyAuth(options);
 
-  const fetchUser = useCallback(async () => {
-    console.log("[useAuth] fetchUser called");
-    try {
-      setLoading(true);
-      setError(null);
-
-      // Web platform: use cookie-based auth, fetch user from API
-      if (Platform.OS === "web") {
-        console.log("[useAuth] Web platform: fetching user from API...");
-        const apiUser = await Api.getMe();
-        console.log("[useAuth] API user response:", apiUser);
+  // If using Clerk, map Clerk user to our User type
+  const clerkUser = useMemo<User | null>(() => {
+    if (!usingClerk || !clerkAuth.isLoaded || !clerkUserHook.isLoaded || !clerkAuth.isSignedIn || !clerkUserHook.user) {
+      return null;
+    }
 
-        if (apiUser) {
-          const userInfo: Auth.User = {
-            id: apiUser.id,
-            openId: apiUser.openId,
-            name: apiUser.name,
-            email: apiUser.email,
-            loginMethod: apiUser.loginMethod,
-            lastSignedIn: new Date(apiUser.lastSignedIn),
-          };
-          setUser(userInfo);
-          // Cache user info in localStorage for faster subsequent loads
-          await Auth.setUserInfo(userInfo);
-          console.log("[useAuth] Web user set from API:", userInfo);
-        } else {
-          console.log("[useAuth] Web: No authenticated user from API");
-          setUser(null);
-          await Auth.clearUserInfo();
-        }
-        return;
-      }
+    const user = clerkUserHook.user;
+    return {
+      id: user.id,
+      openId: user.id,
+      name: user.fullName || user.firstName || "Usuario",
+      email: user.primaryEmailAddress?.emailAddress || "",
+      loginMethod: user.primaryEmailAddress ? "email" : "oauth",
+      lastSignedIn: user.lastSignInAt ? new Date(user.lastSignInAt) : new Date(),
+    };
+  }, [usingClerk, clerkAuth.isLoaded, clerkAuth.isSignedIn, clerkUserHook.isLoaded, clerkUserHook.user]);
 
-      // Native platform: use token-based auth
-      console.log("[useAuth] Native platform: checking for session token...");
-      const sessionToken = await Auth.getSessionToken();
-      console.log(
-        "[useAuth] Session token:",
-        sessionToken ? `present (${sessionToken.substring(0, 20)}...)` : "missing",
-      );
-      if (!sessionToken) {
-        console.log("[useAuth] No session token, setting user to null");
-        setUser(null);
-        return;
-      }
+  // Determine which auth system to use
+  const user = usingClerk ? clerkUser : legacyAuth.user;
+  const loading = usingClerk ? (!clerkAuth.isLoaded || !clerkUserHook.isLoaded) : legacyAuth.loading;
+  const isAuthenticated = usingClerk ? (clerkAuth.isSignedIn && !!clerkUser) : legacyAuth.isAuthenticated;
 
-      // Use cached user info for native (token validates the session)
-      const cachedUser = await Auth.getUserInfo();
-      console.log("[useAuth] Cached user:", cachedUser);
-      if (cachedUser) {
-        console.log("[useAuth] Using cached user info");
-        setUser(cachedUser);
-      } else {
-        console.log("[useAuth] No cached user, setting user to null");
-        setUser(null);
+  const logout = useCallback(async () => {
+    if (usingClerk) {
+      try {
+        await clerkAuth.signOut();
+      } catch (err) {
+        console.error("[Auth] Clerk logout error:", err);
       }
-    } catch (err) {
-      const error = err instanceof Error ? err : new Error("Failed to fetch user");
-      console.error("[useAuth] fetchUser error:", error);
-      setError(error);
-      setUser(null);
-    } finally {
-      setLoading(false);
-      console.log("[useAuth] fetchUser completed, loading:", false);
+    } else {
+      await legacyAuth.logout();
     }
-  }, []);
+  }, [usingClerk, clerkAuth, legacyAuth]);
 
-  const logout = useCallback(async () => {
-    try {
-      await Api.logout();
-    } catch (err) {
-      console.error("[Auth] Logout API call failed:", err);
-      // Continue with logout even if API call fails
-    } finally {
-      await Auth.removeSessionToken();
-      await Auth.clearUserInfo();
-      setUser(null);
-      setError(null);
+  const refresh = useCallback(async () => {
+    if (usingClerk) {
+      // Clerk handles this automatically
+      console.log("[useAuth] Refresh called - Clerk handles this automatically");
+    } else {
+      await legacyAuth.refresh();
     }
-  }, []);
+  }, [usingClerk, legacyAuth]);
 
-  const isAuthenticated = useMemo(() => Boolean(user), [user]);
-
-  useEffect(() => {
-    console.log("[useAuth] useEffect triggered, autoFetch:", autoFetch, "platform:", Platform.OS);
-    if (autoFetch) {
-      if (Platform.OS === "web") {
-        // Web: fetch user from API directly (user will login manually if needed)
-        console.log("[useAuth] Web: fetching user from API...");
-        fetchUser();
-      } else {
-        // Native: check for cached user info first for faster initial load
-        Auth.getUserInfo().then((cachedUser) => {
-          console.log("[useAuth] Native cached user check:", cachedUser);
-          if (cachedUser) {
-            console.log("[useAuth] Native: setting cached user immediately");
-            setUser(cachedUser);
-            setLoading(false);
-          } else {
-            // No cached user, check session token
-            fetchUser();
-          }
-        });
+  // Get session token for API calls
+  const getSessionToken = useCallback(async () => {
+    if (usingClerk) {
+      try {
+        const token = await clerkAuth.getToken();
+        return token;
+      } catch (err) {
+        console.error("[Auth] Error getting Clerk token:", err);
+        return null;
       }
-    } else {
-      console.log("[useAuth] autoFetch disabled, setting loading to false");
-      setLoading(false);
     }
-  }, [autoFetch, fetchUser]);
-
-  useEffect(() => {
-    console.log("[useAuth] State updated:", {
-      hasUser: !!user,
-      loading,
-      isAuthenticated,
-      error: error?.message,
-    });
-  }, [user, loading, isAuthenticated, error]);
+    return null;
+  }, [usingClerk, clerkAuth]);
 
   return {
     user,
     loading,
-    error,
+    error: usingClerk ? null : legacyAuth.error,
     isAuthenticated,
-    refresh: fetchUser,
+    refresh,
     logout,
+    getSessionToken,
+    usingClerk,
   };
 }
diff --git a/lib/clerk-token-cache.ts b/lib/clerk-token-cache.ts
new file mode 100644
index 0000000..bba010c
--- /dev/null
+++ b/lib/clerk-token-cache.ts
@@ -0,0 +1,44 @@
+import * as SecureStore from "expo-secure-store";
+import { Platform } from "react-native";
+import type { TokenCache } from "@clerk/clerk-expo";
+
+const createTokenCache = (): TokenCache => {
+  return {
+    getToken: async (key: string) => {
+      try {
+        if (Platform.OS === "web") {
+          return localStorage.getItem(key);
+        }
+        const item = await SecureStore.getItemAsync(key);
+        return item;
+      } catch (error) {
+        console.error("[TokenCache] Error getting token:", error);
+        return null;
+      }
+    },
+    saveToken: async (key: string, token: string) => {
+      try {
+        if (Platform.OS === "web") {
+          localStorage.setItem(key, token);
+          return;
+        }
+        await SecureStore.setItemAsync(key, token);
+      } catch (error) {
+        console.error("[TokenCache] Error saving token:", error);
+      }
+    },
+    clearToken: async (key: string) => {
+      try {
+        if (Platform.OS === "web") {
+          localStorage.removeItem(key);
+          return;
+        }
+        await SecureStore.deleteItemAsync(key);
+      } catch (error) {
+        console.error("[TokenCache] Error clearing token:", error);
+      }
+    },
+  };
+};
+
+export const tokenCache = createTokenCache();
diff --git a/package.json b/package.json
index c4d2e09..5874690 100644
--- a/package.json
+++ b/package.json
@@ -21,6 +21,8 @@
     "db:push": "drizzle-kit generate && drizzle-kit migrate"
   },
   "dependencies": {
+    "@clerk/clerk-expo": "^2.9.0",
+    "@clerk/backend": "^1.21.0",
     "@aws-sdk/client-s3": "^3.958.0",
     "@aws-sdk/s3-request-presigner": "^3.958.0",
     "@expo/vector-icons": "^15.0.3",
diff --git a/server/_core/clerk.ts b/server/_core/clerk.ts
new file mode 100644
index 0000000..7320aef
--- /dev/null
+++ b/server/_core/clerk.ts
@@ -0,0 +1,121 @@
+import { createClerkClient, verifyToken } from "@clerk/backend";
+import type { VercelRequest } from "@vercel/node";
+
+// Initialize Clerk client
+const clerkClient = createClerkClient({
+  secretKey: process.env.CLERK_SECRET_KEY,
+});
+
+export { clerkClient };
+
+// Type for authenticated user from Clerk
+export type ClerkUser = {
+  id: string;
+  email: string;
+  name: string;
+  imageUrl?: string;
+};
+
+/**
+ * Verify the Clerk session token from the request
+ */
+export async function verifyClerkSession(req: VercelRequest): Promise<ClerkUser | null> {
+  try {
+    // Get the session token from the Authorization header or cookie
+    const authHeader = req.headers.authorization;
+    const sessionToken = authHeader?.startsWith("Bearer ") 
+      ? authHeader.substring(7) 
+      : null;
+
+    if (!sessionToken) {
+      console.log("[Clerk] No session token found in request");
+      return null;
+    }
+
+    // Verify the token
+    const secretKey = process.env.CLERK_SECRET_KEY;
+    if (!secretKey) {
+      console.error("[Clerk] CLERK_SECRET_KEY not configured");
+      return null;
+    }
+
+    const payload = await verifyToken(sessionToken, {
+      secretKey,
+    });
+
+    if (!payload || !payload.sub) {
+      console.log("[Clerk] Invalid token payload");
+      return null;
+    }
+
+    // Get the user details from Clerk
+    const user = await clerkClient.users.getUser(payload.sub);
+
+    return {
+      id: user.id,
+      email: user.emailAddresses[0]?.emailAddress || "",
+      name: `${user.firstName || ""} ${user.lastName || ""}`.trim() || "Usuario",
+      imageUrl: user.imageUrl,
+    };
+  } catch (error) {
+    console.error("[Clerk] Error verifying session:", error);
+    return null;
+  }
+}
+
+/**
+ * Get or create a user in the database based on Clerk user
+ */
+export async function getOrCreateUserFromClerk(
+  clerkUser: ClerkUser,
+  db: any,
+  users: any,
+  eq: any
+): Promise<{ id: string; email: string; name: string }> {
+  // Check if user exists in database
+  const existingUsers = await db
+    .select()
+    .from(users)
+    .where(eq(users.openId, clerkUser.id))
+    .limit(1);
+
+  if (existingUsers.length > 0) {
+    // Update last sign in
+    await db
+      .update(users)
+      .set({ lastSignedIn: new Date() })
+      .where(eq(users.id, existingUsers[0].id));
+    
+    return existingUsers[0];
+  }
+
+  // Create new user
+  const newUser = {
+    openId: clerkUser.id,
+    email: clerkUser.email,
+    name: clerkUser.name,
+    loginMethod: "clerk",
+    lastSignedIn: new Date(),
+  };
+
+  const result = await db.insert(users).values(newUser);
+  const insertedId = result[0]?.insertId;
+
+  if (insertedId) {
+    const [createdUser] = await db
+      .select()
+      .from(users)
+      .where(eq(users.id, insertedId))
+      .limit(1);
+    return createdUser;
+  }
+
+  // If insert didn't return ID, fetch by openId
+  const [createdUser] = await db
+    .select()
+    .from(users)
+    .where(eq(users.openId, clerkUser.id))
+    .limit(1);
+
+  return createdUser;
+}
diff --git a/server/_core/context.ts b/server/_core/context.ts
index b0fa1b4..4b946a7 100644
--- a/server/_core/context.ts
+++ b/server/_core/context.ts
@@ -1,5 +1,9 @@
 import type { User } from "../../drizzle/schema.js";
 import { sdk } from "./sdk.js";
+import { verifyClerkSession, getOrCreateUserFromClerk } from "./clerk.js";
+import { db } from "../db/index.js";
+import { users } from "../../drizzle/schema.js";
+import { eq } from "drizzle-orm";
 
 // Generic request/response types that work with both Express and Vercel
 export type TrpcContext = {
@@ -17,8 +21,26 @@ export type CreateContextOptions = {
 export async function createContext(opts: CreateContextOptions): Promise<TrpcContext> {
   let user: User | null = null;
 
+  // Try Clerk authentication first (new system)
+  try {
+    const clerkUser = await verifyClerkSession(opts.req);
+    if (clerkUser) {
+      // Get or create user in database
+      const dbUser = await getOrCreateUserFromClerk(clerkUser, db, users, eq);
+      user = dbUser as User;
+      console.log("[Context] Authenticated via Clerk:", user.email);
+      return { req: opts.req, res: opts.res, user };
+    }
+  } catch (error) {
+    console.log("[Context] Clerk auth failed, trying legacy auth:", error);
+  }
+
+  // Fall back to legacy SDK authentication (demo login, etc.)
   try {
     user = await sdk.authenticateRequest(opts.req);
+    if (user) {
+      console.log("[Context] Authenticated via legacy SDK:", user.email);
+    }
   } catch (error) {
     // Authentication is optional for public procedures.
     user = null;
